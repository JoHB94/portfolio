import{_ as a,c as r,o,ab as n}from"./chunks/framework.Dsgp4YlQ.js";const s="/portfolio/mataju/Mataju_%EC%84%9C%EB%B2%84AWS%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png",e="/portfolio/mataju/Mataju_%EB%B0%B0%ED%8F%ACAWS%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.png",i="/portfolio/mataju/Mataju_CDAction.png",b=JSON.parse('{"title":"🏗️Mataju 아키텍처","description":"","frontmatter":{},"headers":[],"relativePath":"Mataju/MatajuArchitecture/architecture.md","filePath":"Mataju/MatajuArchitecture/architecture.md","lastUpdated":null}'),g={name:"Mataju/MatajuArchitecture/architecture.md"};function u(c,t,l,h,d,p){return o(),r("div",null,t[0]||(t[0]=[n('<h1 id="🏗️mataju-아키텍처" tabindex="-1">🏗️Mataju 아키텍처 <a class="header-anchor" href="#🏗️mataju-아키텍처" aria-label="Permalink to &quot;🏗️Mataju 아키텍처&quot;">​</a></h1><h2 id="mataju-아키텍처-구성" tabindex="-1">Mataju 아키텍처 구성 <a class="header-anchor" href="#mataju-아키텍처-구성" aria-label="Permalink to &quot;Mataju 아키텍처 구성&quot;">​</a></h2><h3 id="_1-mataju-서버" tabindex="-1">1. <strong>Mataju 서버</strong> <a class="header-anchor" href="#_1-mataju-서버" aria-label="Permalink to &quot;1. **Mataju 서버**&quot;">​</a></h3><p><strong>오토스케일링과 로드밸런싱을 활용한 분산 시스템 설계</strong></p><p><img src="'+s+'" alt="Mataju 아키텍처"></p><h4 id="🔹-왜-모놀리식이-아닌가-monolithic-vs-distributed-architecture" tabindex="-1">🔹 <strong>왜 모놀리식이 아닌가? (Monolithic vs. Distributed Architecture)</strong> <a class="header-anchor" href="#🔹-왜-모놀리식이-아닌가-monolithic-vs-distributed-architecture" aria-label="Permalink to &quot;🔹 **왜 모놀리식이 아닌가? (Monolithic vs. Distributed Architecture)**&quot;">​</a></h4><p>기존의 <strong>모놀리식 아키텍처</strong>는 하나의 서버에서 모든 기능(API, DB, 로직)을 처리하는 방식입니다.<br> 하지만, 이 방식은 <strong>트래픽 증가 시 확장이 어렵고, 하나의 장애가 전체 시스템에 영향을 미치는 단점</strong>이 있습니다.</p><p>이에 반해, <strong>Mataju의 AWS 배포 방식</strong>은 <strong>오토스케일링(Auto Scaling)과 로드밸런싱(Load Balancing)</strong> 을 기반으로 <strong>분산된 아키텍처</strong>를 사용하여 아래와 같은 이점을 제공합니다:</p><p>✅ <strong>확장성 (Scalability)</strong> → 트래픽 증가 시 <strong>EC2 인스턴스 자동 확장</strong><br> ✅ <strong>가용성 (Availability)</strong> → <strong>다중 가용영역(AZ) 배포</strong>를 통해 <strong>서비스 중단 방지</strong><br> ✅ <strong>부하 분산 (Load Balancing)</strong> → <strong>ALB(Application Load Balancer)</strong> 로 <strong>트래픽을 균등하게 분산</strong><br> ✅ <strong>복구력 (Fault Tolerance)</strong> → 특정 <strong>인스턴스 장애 발생 시 자동 복구</strong></p><p>이러한 설계를 통해 <strong>높은 확장성과 안정성을 보장하는 클라우드 네이티브 시스템</strong>을 구축할 수 있습니다. 🚀</p><hr><hr><h3 id="_2-다양한-버전의-클라이언트" tabindex="-1">2. <strong>다양한 버전의 클라이언트</strong> <a class="header-anchor" href="#_2-다양한-버전의-클라이언트" aria-label="Permalink to &quot;2. **다양한 버전의 클라이언트**&quot;">​</a></h3><p><img src="'+e+'" alt="Mataju 아키텍처"></p><h4 id="🔹-실제-개발-환경과-의미-부여" tabindex="-1">🔹 <strong>실제 개발 환경과 의미 부여</strong> <a class="header-anchor" href="#🔹-실제-개발-환경과-의미-부여" aria-label="Permalink to &quot;🔹 **실제 개발 환경과 의미 부여**&quot;">​</a></h4><p>Mataju 프로젝트는 표면적으로는 <strong>Windows, macOS, Linux</strong> 세 가지 버전의 클라이언트를 지원합니다.<br> 하지만, 실제로는 <strong>세 가지의 WPF 클라이언트 애플리케이션</strong>이 개발되었습니다.</p><h4 id="🔹-왜-동일한-os에서-3개의-클라이언트가-나왔는가" tabindex="-1">🔹 <strong>왜 동일한 OS에서 3개의 클라이언트가 나왔는가?</strong> <a class="header-anchor" href="#🔹-왜-동일한-os에서-3개의-클라이언트가-나왔는가" aria-label="Permalink to &quot;🔹 **왜 동일한 OS에서 3개의 클라이언트가 나왔는가?**&quot;">​</a></h4><p>✅ <strong>WPF/MVVM 학습 환경</strong> → 팀원 모두 WPF/MVVM을 처음 학습하는 단계였음<br> ✅ <strong>협업보다 개별 학습이 유리</strong> → 서로 리딩하며 협업하는 것보다, 개별적으로 공부한 내용을 적용하며 개발하는 방식 선택<br> ✅ <strong>결과물의 의미 부여</strong> → Windows에서 동작하는 3개의 애플리케이션을, <strong>향후 확장성을 고려하여 OS별 버전으로 의미 부여</strong></p><hr><hr><h3 id="_3-배포-랜딩-페이지-및-자동화" tabindex="-1">3. <strong>배포 랜딩 페이지 및 자동화</strong> <a class="header-anchor" href="#_3-배포-랜딩-페이지-및-자동화" aria-label="Permalink to &quot;3. **배포 랜딩 페이지 및 자동화**&quot;">​</a></h3><h4 id="🔹-wpf-애플리케이션의-배포-방식" tabindex="-1">🔹 <strong>WPF 애플리케이션의 배포 방식</strong> <a class="header-anchor" href="#🔹-wpf-애플리케이션의-배포-방식" aria-label="Permalink to &quot;🔹 **WPF 애플리케이션의 배포 방식**&quot;">​</a></h4><p>WPF 애플리케이션은 <strong>윈도우 전용 실행 파일(EXE) 형태로 배포</strong>되기 때문에, 사용자가 쉽게 최신 버전을 다운로드할 수 있도록 <strong>배포 전용 페이지</strong>를 구축했습니다.</p><h4 id="🔹-cd-continuous-deployment-파이프라인-구축" tabindex="-1">🔹 <strong>CD(Continuous Deployment) 파이프라인 구축</strong> <a class="header-anchor" href="#🔹-cd-continuous-deployment-파이프라인-구축" aria-label="Permalink to &quot;🔹 **CD(Continuous Deployment) 파이프라인 구축**&quot;">​</a></h4><p><img src="'+i+'" alt="MatajuCD"><br> 각 OS별 버전이 업데이트될 때마다 <strong>자동으로 배포</strong>되도록 <strong>CD 파이프라인</strong>을 구축했습니다.</p><p>✅ <strong>배포 전용 웹페이지 제공</strong> → 사용자가 최신 버전을 쉽게 다운로드 가능<br> ✅ <strong>자동 배포</strong> → 새로운 릴리스가 발생하면 자동으로 배포 페이지 갱신<br> ✅ <strong>AWS S3 + GitHub Actions 활용</strong> → 코드 변경 시 자동으로 빌드 &amp; 배포</p><p>이러한 자동화 시스템을 통해 <strong>배포 과정의 효율성을 극대화하고, 사용자가 항상 최신 버전을 받을 수 있도록 보장</strong>하였습니다. 🚀</p>',27)]))}const j=a(g,[["render",u]]);export{b as __pageData,j as default};
